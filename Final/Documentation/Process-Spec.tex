\section{Module 3: Process Scheduling and Context Switching}
\label{Process-Spec}

This section describes how processes are represented, created, and completed within our simulated \texttt{OS}. 

\subsection{Problem Statement}
\label{PS-m3}

In this module, you will extend the simulator by implementing advanced process scheduling algorithms and context switching mechanisms. The goal is to manage multiple processes efficiently while ensuring fair distribution of CPU time and supporting real-time constraints. This module will prepare the simulator to handle diverse workloads and process types (CPU-bound, I/O-bound, and mixed), laying the foundation for multitasking and system responsiveness.

\subsection{Implementation}
\label{IMP-m3}

This section outlines the our solution to the problem statement. \Cref{PCB} presents out we extended the PCB structure from \Cref{module1}. \Cref{Scheduling} describes out we implemented the seven advanced scheduling algorithms. \Cref{cont-sw} shows how we handle context switching for the preemptive scheduling algorithms. Finally, \Cref{fetNdec} explains how we integrated the fetch-decode-execute cycle with processes and scheduling logic.

\subsubsection{Process Control Block Enhancements}
\label{PCB}

\begin{figure}[h]
	\begin{lstlisting}[language=MyC, escapechar=\%, numbers=none]
typedef enum {
    READY,
    RUNNING,
    SUSPEND_READY,
    BLOCKED,
    SUSPEND_BLOCKED,
    NEW,
    FINISHED
} ProcessState;

//To represent a process
typedef struct {
    int pid; //process id
    int pc; //program counter 
    ProcessState state; //state of the process
    int priority; //priority level
    int burstTime; //time left to complete
    float responseRatio; //calculated as (waiting time + service time)
    Cpu cpu_state; // the state of the cpu
    uint32_t text_start; // Where code is in memory
    uint32_t text_size; // where said code is
    uint32_t data_start; // Where data is in memory
    uint32_t data_size; // Size of said data
    uint32_t stack_ptr; // Stack pointer value
} Process;
	\end{lstlisting}
	\caption{Representation of Processes}

\end{figure}


\subsubsection{Scheduling Algorithms}
\label{Scheduling}

\begin{figure}[h]
	\begin{lstlisting}[language=MyC, escapechar=\%, numbers=none]
//To represent a queue
typedef struct {
    int next; //the index to next open space
    int capacity; //The size of the queue
    Process PCB[]; //The block to hold processes
} Queue;
	\end{lstlisting}
	\caption{Representation of Queue}
\end{figure}

\subsubsection*{Round-Robin}
\label{RR}

For the Round-Robin scheduling algorithm, we chose to have a time quantum of 3. 

\begin{figure}
	\begin{lstlisting}[language=MyC, escapechar=\%, numbers=none]
//the round robin scheduling algorithm
static void roundRobin(void) {
	int idx = 0;
	while (Ready_Queue->next != 0) {
		transferProcesses(NORMAL);
		Process currentProcess = Ready_Queue->PCB[idx];
		
		set_current_process(currentProcess.pid);
		
		transitionState(currentProcess, NORMAL);
		for (int i = 0; i < QUANTUM; i++) {
			fetch();
			execute();
			currentProcess.burstTime-=1; //could make ternary
		}
		
		if (currentProcess.burstTime > 0 && idx+1 >= Ready_Queue->next) {
			context_switch(NORMAL, true);
			idx = 0;
		} else if (currentProcess.burstTime > 0) {
			context_switch(NORMAL, true);
			idx+=1;
		} else {
			transitionState(currentProcess, NORMAL);
		}
		
	}
	\end{lstlisting}
	
\end{figure}


\subsubsection*{Priority-Based Scheduling}
\label{PBS}

lsf

\subsubsection*{Shortest Time Remaining}
\label{SRT}

lsf

\subsubsection*{Highest Response Ratio Next}
\label{HRRN}
lsv

\subsubsection*{First Come First Serve}
\label{FCFS}


kfs
\subsubsection*{Shortest Process Next}
\label{SPN}

 skf

\subsubsection*{Feedback Scheduling}
\label{FS}

jsnf

\subsubsection{Context Switching}
\label{cont-sw}

snfj
\subsubsection{Integration with Fetch-Decode-Execute Cycle}
\label{fetNdec}

jnsf