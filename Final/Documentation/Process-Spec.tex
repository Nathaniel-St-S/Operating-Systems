\section{Module 3: Process Scheduling and Context Switching}
\label{Process-Spec}

This section describes how processes are represented, created, and completed within our simulated \texttt{OS}. 

\subsection{Problem Statement}
\label{PS-m3}

In this module, you will extend the simulator by implementing advanced process scheduling algorithms and context switching mechanisms. The goal is to manage multiple processes efficiently while ensuring fair distribution of CPU time and supporting real-time constraints. This module will prepare the simulator to handle diverse workloads and process types (CPU-bound, I/O-bound, and mixed), laying the foundation for multitasking and system responsiveness.

\subsection{Implementation}
\label{IMP-m3}

This section outlines the our solution to the problem statement. \Cref{PCB} presents out we extended the PCB structure from \Cref{module1}. \Cref{Scheduling} describes out we implemented the seven advanced scheduling algorithms. \Cref{cont-sw} shows how we handle context switching for the preemptive scheduling algorithms. Finally, \Cref{fetNdec} explains how we integrated the fetch-decode-execute cycle with processes and scheduling logic.

\subsubsection{Process Control Block Enhancements}
\label{PCB}

\begin{figure}[h]
	\begin{lstlisting}[language=MyC, escapechar=\$, numbers=none]
typedef enum {
    READY,
    RUNNING,
    SUSPEND_READY,
    BLOCKED,
    SUSPEND_BLOCKED,
    NEW,
    FINISHED
} ProcessState;

//To represent a process
typedef struct {
    int pid; //process id
    ProcessState state; //state of the process
    int priority; //priority level
    int burstTime; //time left to complete
    float responseRatio; //calculated as (waiting time + service time)
    Cpu cpu_state; // the state of the cpu
    uint32_t text_start; // Where code is in memory
    uint32_t text_size; // where said code is
    uint32_t data_start; // Where data is in memory
    uint32_t data_size; // Size of said data
    uint32_t stack_ptr; // Stack pointer value
} Process;
	\end{lstlisting}
	\caption{Representation of Processes}
	\label{process-impl}
\end{figure}

\Cref{process-impl} displays the representation of processes in our \os{}. We follow a 7-state model where a process can be in one of seven states:

\begin{enumerate}
	\item READY
	\item RUNNING
	\item SUSPEND\textunderscore{}READY
	\item BLOCKED
	\item SUSPEND\textunderscore{}BLOCKED
	\item NEW
	\item FINISHED
\end{enumerate}

The process structure contains a process id (pid), the state of the process (state), the priority of the process (priority), the burst time of the process (burstTime), the response ratio for the response (responseRatio), the state of the cpu for context switching (cpu\textunderscore{}state), the location to the start of code in memory for the process (text\textunderscore{}start), the location of the code in memory for the process (text\textunderscore{}size), the location to the state of data in memory for the process (data\textunderscore{}start), the location of the data in memory for the process (data\textunderscore{}size), and finally the stack pointer for the process (stack\textunderscore{}ptr).


\subsubsection{Scheduling Algorithms}
\label{Scheduling}

\begin{figure}[h!]
	\begin{lstlisting}[language=MyC, escapechar=\$, numbers=none]
//To represent a queue
typedef struct {
    int next; //the index to next open space
    int capacity; //The size of the queue
    Process PCB[]; //The block to hold processes
} Queue;
	\end{lstlisting}
	\caption{Representation of Queue}
	\label{queue-impl}
\end{figure}


To implement the seven scheduling algorithms for our \os{}, we first needed a queue to hold all of the processes. This led to creating the Queue structure displayed in \Cref{queue-impl}. The queue structure contains the index to the next open space in the queue (next), the size of queue (capacity), and an array holding all of the processes (PCB). We made a queue for each state that the process can have as well as priority ready queue with respect to burst time and priority. In the interest of brevity, the scheduling algorithm will be explained at a high level of abstraction. 

\begin{figure}[h]
	\begin{lstlisting}[language=MyC, escapechar=\$, numbers=none]
		//the round robin scheduling algorithm
		static void roundRobin(void) {
			int idx = 0;
			while (Ready_Queue->next != 0) {
				transferProcesses(NORMAL);
				Process currentProcess = Ready_Queue->PCB[idx];
				set_current_process(currentProcess.pid);
				transitionState(currentProcess, NORMAL);
				
				for (int i = 0; i < QUANTUM; i++) {
					fetch();
					execute();
					currentProcess.burstTime-=1; 
				}
				
				if (currentProcess.burstTime > 0 && idx+1 >= Ready_Queue->next) {
					context_switch(NORMAL, true);
					idx = 0;
				} else if (currentProcess.burstTime > 0) {
					context_switch(NORMAL, true);
					idx+=1;
				} else {
					transitionState(currentProcess, NORMAL);
				}
			}
		\end{lstlisting}
		\caption{The Round-Robin Scheduling algorithm}
		\label{RR-impl}
	\end{figure}

\subsubsection*{Round-Robin}
\label{RR}



The Round-Robin scheduling algorithm is displayed \Cref{RR-impl} and we chose to have a time quantum of 3. While the ready queue is not empty, we loop over the following sequence:

\begin{enumerate}
	\item Check for new processes
	\item Get the current process and transition it's state
	\item Execute the time slice for the current process
	\item Check if process is finished:
	\begin{enumerate}
		\item If the process is finished, transition it's state
		\item Otherwise switch the context
	\end{enumerate}
\end{enumerate}

\subsubsection*{Priority-Based Scheduling}
\label{PBS}

\begin{figure}[h]
	\begin{lstlisting}[language=MyC, escapechar=\$, numbers=none]
		//uses priorityPriorityQueue 
		//the priority based scheduling algorithm
		static void priorityBased(void) {
			while (Ready_Queue->next != 0) {
				transferProcesses(PRIORITYPRIORITY);
				Process highestPriorityP = Ready_Queue->PCB[0];
				set_current_process(highestPriorityP.pid);
				transitionState(highestPriorityP, PRIORITYPRIORITY);
				
				while (highestPriorityP.burstTime > 0) {
					fetch();
					execute();
					highestPriorityP.burstTime-=1;
					transferProcesses(PRIORITYPRIORITY);
					Process newHighestP = Ready_Queue->PCB[0];
					
					if (&newHighestP != &highestPriorityP) {
						if (&Ready_Queue->PCB[1] == &newHighestP) {
							context_switch(PRIORITYPRIORITY, true);
						} else {
							context_switch(PRIORITYPRIORITY, true);
						}
					}
				}
				transitionState(highestPriorityP, PRIORITYPRIORITY);
			}
			set_current_process(SYSTEM_PROCESS_ID);
		}
		\end{lstlisting}
		\caption{The Priority Based Scheduling algorithm}
		\label{PBS-impl}
	\end{figure}

The implementation of the Priority-Based scheduling algorithm is found in \Cref{PBS-impl}. We implemented a ready queue where the processes are sorted with respect to priority. While the ready queue is not empty, we loop over the following sequence: 

\begin{enumerate}
	\item Check for new processes
	\item Get the current process and transition it's state
	\item Execute the current process, check for new processes and get the process with the new highest priority:
	\begin{enumerate}
		\item If new process is different from the current process, switch the context
		\item Otherwise continue executing the current process
	\end{enumerate}
	\item When the current process is finished, transition it's state
\end{enumerate}

\subsubsection*{Shortest Time Remaining}
\label{SRT}

\begin{figure}[h]
	\begin{lstlisting}[language=MyC, escapechar=\$, numbers=none]
		//uses priorityBurstQueue 
		//the shortest time remaining scheduling algorithm
		static void shortestRemainingTime(void) {
			while (Ready_Queue->next != 0) {
				transferProcesses(PRIORITYBURST);
				Process shortestBTimeP = Ready_Queue->PCB[0];
				set_current_process(shortestBTimeP.pid);
				transitionState(shortestBTimeP, PRIORITYBURST);
				
				while (shortestBTimeP.burstTime > 0) {
					fetch();
					execute();
					shortestBTimeP.burstTime-=1;
					transferProcesses(PRIORITYBURST);
					Process newShortestBTimeP = Ready_Queue->PCB[0];
					
					if (&newShortestBTimeP != &shortestBTimeP) {
						if (&Ready_Queue->PCB[1] == &newShortestBTimeP) {
							context_switch(PRIORITYBURST, true);
						} else {
							context_switch(PRIORITYBURST, true);
						}
					}
				}
				transitionState(shortestBTimeP, PRIORITYBURST);
			}
			set_current_process(SYSTEM_PROCESS_ID);
		}
	\end{lstlisting}
	\caption{The Shortest Time Remaining Scheduling algorithm}
	\label{SRT-impl}
\end{figure}

The implementation of the Shortest Time Remaining scheduling algorithm is found in \Cref{SRT-impl}. We implemented a ready queue where the processes are sorted with respect to burst time. While the ready queue is not empty, we loop over the following sequence: 

\begin{enumerate}
	\item Check for new processes
	\item Get the current process and transition it's state
	\item Execute the current process, check for new processes and get the process with the new smallest burst:
	\begin{enumerate}
		\item If new process is different from the current process, switch the context
		\item Otherwise continue executing the current process
	\end{enumerate}
	\item When the current process is finished, transition it's state
\end{enumerate}

\subsubsection*{Highest Response Ratio Next}
\label{HRRN}

\begin{figure}[h]
	\begin{lstlisting}[language=MyC, escapechar=\$, numbers=none]
		//the highest response ratio next scheduling algorithm
		static void highestResponseRatioNext(void) {
			transferProcesses(NORMAL);
			if (Ready_Queue->next != 0) {
				int total_time = 0;
				Process currentProcess = Ready_Queue->PCB[0];
				set_current_process(currentProcess.pid);
				total_time = currentProcess.burstTime;
				transitionState(currentProcess, NORMAL);
				
				while (Ready_Queue->next != 0) {
					transferProcesses(NORMAL);
					while (currentProcess.burstTime > 0) {
						fetch();
						execute();
						currentProcess.burstTime-=1;
					}
					
					transitionState(currentProcess, NORMAL);
					updateResponseRatio(Ready_Queue, total_time); 
					currentProcess = getHighestResponseRatio();
					total_time = currentProcess.burstTime;
					transitionState(currentProcess, NORMAL);
				}
			}
			set_current_process(SYSTEM_PROCESS_ID);
		}
	\end{lstlisting}
	\caption{The Highest Response Ratio Next Scheduling algorithm}
	\label{HRRN-impl}
\end{figure}

The implementation of the Highest Response Ratio Next scheduling algorithm is found in \Cref{HRRN-impl}.  While the ready queue is not empty, we loop over the following sequence: 

\begin{enumerate}
	\item Check for new processes
	\item Get the current process, transition it's state and accumulate it's burst time
	\item Execute the current process to completion and transition it's state
	\item Update the response ratio for the remaining processes and get the process with the new highest response ratio
\end{enumerate}

\subsubsection*{First Come First Serve}
\label{FCFS}

\begin{figure}[h!]
	\begin{lstlisting}[language=MyC, escapechar=\$, numbers=none]
		//The first come first serve scheduling algorithm
		static void firstComeFirstServe(void) {
			while (Ready_Queue->next != 0) {
				transferProcesses(NORMAL);
				Process currentProcess = Ready_Queue->PCB[0];
				set_current_process(currentProcess.pid);
				transitionState(currentProcess, NORMAL);
				
				while (currentProcess.burstTime > 0) {
					fetch();
					execute();
					currentProcess.burstTime-=1;
				}
				transitionState(currentProcess, NORMAL);
			}
			
			set_current_process(SYSTEM_PROCESS_ID);
		}
	\end{lstlisting}
	\caption{The First Come First Serve Scheduling algorithm}
	\label{FCFS-impl}
\end{figure}

The implementation of the First Come First Serve scheduling algorithm is found in \Cref{FCFS-impl}. While the ready queue is not empty, we loop over the following sequence: 

\begin{enumerate}
	\item Check for new processes
	\item Get the current process and transition it's state
	\item Execute the current process to completion then transition it's state 
\end{enumerate}

\subsubsection*{Shortest Process Next}
\label{SPN}

 \begin{figure}[h]
 	\begin{lstlisting}[language=MyC, escapechar=\$, numbers=none]
 		//uses priorityBurstQueue 
 		//the shortest process next scheduling algorithm
 		static void shortestProcessNext(void) {
 			while (Ready_Queue->next != 0) {
 				transferProcesses(PRIORITYBURST);
 				Process shortestProcess = Ready_Queue->PCB[0];
 				set_current_process(shortestProcess.pid);
 				transitionState(shortestProcess, PRIORITYBURST);
 				
 				while(shortestProcess.burstTime > 0) {
 					fetch();
 					execute();
 					shortestProcess.burstTime-=1;
 				}
 				transitionState(shortestProcess, PRIORITYBURST); 
 			}
 			
 			set_current_process(SYSTEM_PROCESS_ID);
 		}
 	\end{lstlisting}
 	\caption{The Shortest Process Next Scheduling algorithm}
 	\label{SPN-impl}
 \end{figure}

The implementation of the Shortest Process Next scheduling algorithm is found in \Cref{SPN-impl}. We implemented a ready queue where the processes are sorted with respect to burst time. While the ready queue is not empty, we loop over the following sequence: 

\begin{enumerate}
	\item Check for new processes
	\item Get the process with the smallest burst time and transition it's state
	\item Execute the current process to completion and transition it's state
\end{enumerate}

\subsubsection*{Feedback Scheduling}
\label{FBS}

\begin{figure}[h]
	\begin{lstlisting}[language=MyC, escapechar=\$, numbers=none]
		//the feedback scheduling algorithm
		static void feedBack(void) {
			Queue* feedBack_Q2 = init_FeedBack_Queue(MAX_PROCESSES);
			Queue* feedBack_Q3 = init_FeedBack_Queue(MAX_PROCESSES);
			int quantum1 = 2;
			int quantum2 = 4;
			
			while(true) {
				transferProcesses(NORMAL);
				//handle processes in highest priority queue with 2 quantum
				handleQueue(Ready_Queue, quantum1, false);
				//handle processes in middle priority queue with 4 quantum
				handleQueue(feedBack_Q2, quantum2, false); 
				//handle processes in lowest priority queue FCFS
				handleQueue(feedBack_Q3, 0, true);
				
				//Moves unfinished processes from ready_queue to middle priority queue
				moveProcesses(Ready_Queue);
				//Moves unfinished processes from middle priority queue to lowest queue
				moveProcesses(feedBack_Q2);
				//move process from lowest priority queue to finished queue
				moveProcesses(feedBack_Q3);
				
				if (Ready_Queue->next == 0 && feedBack_Q2->next == 0 && feedBack_Q3->next == 0) {
					break;
				}
			}
			
			free_Queue(feedBack_Q2);
			free_Queue(feedBack_Q3);
			set_current_process(SYSTEM_PROCESS_ID);
		}
	\end{lstlisting}
	\caption{The Feed Back Scheduling algorithm}
	\label{FBS-impl}
\end{figure}

The implementation of the Feed Back scheduling algorithm is found in \Cref{FBS-impl}. We implemented a 3 ready queues where the processes are moved to the lower queues if they are not completed. While all three queues are not empty, we loop over the following sequence: 

\begin{enumerate}
	\item Check for new processes
	\item Execute the process in the highest priority queue, then middle priority queue and finally the lowest priority queue
	\item Move the unfinished processes from the highest priority to the middle priority queue
	\item Move the unfinished processes from the middle priority queue to the lowest priority queue
	\item Move finished processes from lowest priority queue to the finished queue
	\item When the current process is finished, transition it's state
\end{enumerate}

\subsubsection{Context Switching}
\label{cont-sw}

\begin{figure}[h!]
	\begin{lstlisting}[language=MyC, escapechar=\$, numbers=none]
		//Switches from one process to another
		static void context_switch(int queue_type, bool needTransition) {
			Process curr = Running_Queue->PCB[0];
			Process nxt = Ready_Queue->PCB[0];
			
			//save current's state
			curr.cpu_state = THE_CPU;
			
			set_current_process(nxt.pid);
			
			//start the next process
			THE_CPU = nxt.cpu_state;
			
			if (needTransition) {
				transitionState(curr, queue_type);
				transitionState(nxt, queue_type);
			}
		}
	\end{lstlisting}
	\caption{Context Switching Implementation}
	\label{consw-impl}
\end{figure}

The implementation for context switching is shown in \Cref{consw-impl}. This function takes in as input an integer designating the type of queue (e.i. a normal queue, a priority queue WRT priority or a priority queue WRT burst time) and a boolean denoting whether the two processes should have their states transitioned. The body of function extracts the first process from the running queue and the first process from the ready queue, called \texttt{curr} and \texttt{nxt} respectively. The current state of the cpu is saved into \texttt{curr} and the state of the cpu found within \texttt{nxt} is extracted and used to update the state of the cpu. Lastly, the processes transition their states if the \texttt{needTransition} argument is true. 

\subsubsection{Integration with Fetch-Decode-Execute Cycle}
\label{fetNdec}

With the addition of schedulers to our \os{}, this requires additional logic for the fetch-decode-execute cycle. As a consequence of the way we implemented the algorithms, we handle most, if not all of the integration within the schedule itself. Each scheduler checks if there a new processes and when applicable, reorders the priority queue such the process with the smallest burst time or priority. In addition, all of the preemptive schedulers handle context switching. 